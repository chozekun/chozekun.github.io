<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[chozekun's blog]]></title>
  <link href="http://chozekun.github.io/atom.xml" rel="self"/>
  <link href="http://chozekun.github.io/"/>
  <updated>2016-04-25T20:28:02+09:00</updated>
  <id>http://chozekun.github.io/</id>
  <author>
    <name><![CDATA[chozekun]]></name>
    <email><![CDATA[chozekun@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Effective Unit Testing] Chapter 1. 좋은 테스트의 약속]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/effective-unit-testing-chapter-1/"/>
    <updated>2016-04-25T13:32:52+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/effective-unit-testing-chapter-1</id>
    <content type="html"><![CDATA[<h2>Chapter 1. 좋은 테스트의 약속</h2>

<h3>테스트의 가치</h3>

<ul>
<li>테스트는 실수를 바로 잡아 준다.</li>
<li><p>대부분의 실수는 단위 테스트만으로도 쉽게 잡을 수 있다.</p></li>
<li><p>테스트는 실사용에 적합한 설계를 끌어내준다.</p></li>
<li>실패하는 테스트를 작성하고, 그 테스트가 성공할 수 있을 만큼의 코드 작성</li>
<li><p>코드의 설계와 기능을 사용자의 시각에서 바라볼 수 있게 끔 해줌</p></li>
<li><p>테스트는 원하는 동작을 명확히 알려주어 군더더기를 없애준다.</p></li>
<li><p>실패하는 테스트를 거쳐간 코드는 필요한 기능을 모두 담고 있으면서도, 이전 방식으로 작성한 코드보다 더욱 간결해짐</p></li>
<li><p>테스트를 작성해서 얻게 되는 가장 큰 수확은 테스트 자체가 아니다. 작성 과정에서 얻는 깨달음이다.</p></li>
<li>신중히 고민해서 만든 100개의 테스트로는 개선 효과가 크게 느껴지겠지만, 이미 3,000개나 갖춰진 상태에서 100개를 추가한다고 해도 변화를 체감하기 어려움</li>
<li>테스트가 단순한 검증 수단 이상임을 깨닫고, 사고의 전환을 통해야만 발견할 수 있는 설계 고지를 점령해야 함</li>
</ul>


<h3>생산성에 영향을 주는 요소</h3>

<p>테스트 코드는 보통 제품 코드보다 간결하다. (조건문이나 반복문을 사용하는 테스트는 많지 않다.)</p>

<p>그렇다고 <strong>테스트 코드를 성의없이 작성(중복도 많고, 쓸데없이 복잡한 테스트)하면 생산성을 저하</strong>시킨다. (엉터리로 작성한 코드는 가독성, 안전성, 신뢰성, 실행 속도에 악영향을 줌)</p>

<p>생산성에 직접적인 영향을 주는 <strong>피드백 주기</strong>와 <strong>디버깅 시간</strong>이 가장 유력한 <strong>야근의 요정</strong>이다. (생산성 저하의 끝판왕은 회의라는 이야기도 있다.)</p>

<blockquote><p><strong>버그 수정 비용의 증가</strong></p>

<p>프로그래머가 버그를 만들자마자 즉시 수정한다면 $5를 쓴 것</p>

<p>같은 결함을 프로젝트 전체 빌드 때 발견하면 비용은 $50가 됨</p>

<p>만약 통합 테스트까지 살아남으면 $500로 증가</p>

<p>시스템 테스트에 이르면 $5,000까지 치솟음</p></blockquote>

<ul>
<li><strong>테스트 실행 속도</strong>는 변경사항을 검증하고 확인하기 위해 기다리는 시간</li>
<li><strong>가독성</strong>이 떨어지면 자연스럽게 분석이 더뎌지고 디버거를 사용해야 할 상황까지 만들 수 있음.</li>
<li><strong>테스트 결과의 정확성</strong>: 실수로 결함을 만들어도 테스트 스위트가 찾아줄거라고 믿어야 함.

<ul>
<li><strong>신뢰성</strong>과 <strong>안전성</strong>이 연관되어 있음.</li>
<li>테스트가 약속한 것을 확실히 잡아내고 몇 번을 수행해도 항시 같은 결과가 나오도록 만들어야 함.</li>
</ul>
</li>
</ul>


<h3>설계 잠재력 곡선</h3>

<p>아래와 같은 상황을 가정하자.</p>

<ol>
<li>제품 코드의 가장 대표적인 시나리오에 대한 테스트 코드 완료</li>
<li>구조상 가장 치명적인 부분에 대한 테스트 코드 완료</li>
<li>리팩토링으로 중복을 제거하고 가독성을 높인 상태</li>
</ol>


<p>이 상태에서 마지막으로 남은 getter/setter 등의 사소한 테스트는 별로 큰 가치가 없다. 단지 테스트 작성만으로 얻을 수 있는 가치의 한계점에 도달한 상태이다.</p>

<p>이 상태에서는 실수가 반복되는 것을 예방하는, 방어적이고 검증 지향적인 가치가 아닌 더 창조적이고 설계 지향적인 가치를 찾아내야 한다.</p>

<p>테스트로 이룰 수 있는 모든 고지를 점령하려면 다음과 같이 해야 한다.</p>

<ol>
<li>테스트 코드도 제품 코드를 다루듯 하라. 믿고 의지할 수 있을 만큼 철저하게 리팩토링하고 높은 품질을 유지하라</li>
<li>테스트를 제품 코드가 목적과 쓰임새에 적합한 구조가 되게끔 이끌어주는 설계 수단으로 활용하라.</li>
</ol>


<p>프로그래머 대부분이 잘 지키지 못하는 쪽은 첫번째다. (이는 이 책이 커버할 내용)
설계 수단으로써의 테스트 쪽은 다음 책들을 참고.</p>

<ol>
<li>[Test Driven] (매닝, 2007)</li>
<li>[Growing Object-Oriented Software, Guided by Tests] (Addison-Wesley, 2009)</li>
</ol>


<h3>설계 수단으로써의 테스트</h3>

<p>전통적으로 테스트는 크게 두 가지 목적을 위한 품질 검증 수단이었다.</p>

<ol>
<li>코드를 작성하는 즉시 정확하게 구현했는지 검사하는 것</li>
<li>코드베이스가 커져도 계속 잘 동작하는 지 지속해서 확인하는 것</li>
</ol>


<p>테스트를 검증 수단으로 활용한다면, <strong>설계</strong> -> 설계대로 <strong>코딩</strong> -> 생각대로 잘 구현되었는지 <strong>테스트</strong>의 순서를 거칠 것이다.</p>

<p>하지만 테스트를 설계 수단으로 이용한다면 <strong>설계 -> 코딩 -> 테스트 순서</strong>가 아닌 <strong>테스트 -> 코딩 -> 설계</strong>로 바뀐다. 마지막 설계 단계는 사실 <strong>리팩토링</strong> 단계로 더 유명하다.</p>

<p>이것이 바로 테스트 선행 프로그래밍 혹은 테스트 주도 개발이라 불리는 개발 방법론이다.</p>

<h3>테스트 주도 개발 (Test Driven Development)</h3>

<p>테스트 주도 개발(줄여서 TDD)은 간단한 아이디어에서 시작된 프로그래밍 훈련법이다.
<strong>실패하는 테스트 없이는 코드를 작성하지 않는다.</strong></p>

<p>테스트를 먼저 작성하면 <strong>테스트로 설계한 제품 코드</strong>가 만들어지며 다음과 같은 긍정적인 효과를 불러온다.</p>

<ol>
<li><strong>사용 가능한 코드가 만들어진다</strong>. 즉 제품 코드의 설계와 API가 활용 시나리오에 적합한 모습으로 거듭난다.</li>
<li><strong>코드가 가벼워진다</strong>. 실제로 활용할 시나리오에서 요구하는 기능만을 담게 된다.</li>
</ol>


<p>첫째로, 다른 모든 컴포넌트가 갖춰졌는지와 상관없이 여러분의 손에는 항시 <strong>명확한 사용 시나리오가 딸린 설계</strong>만이 쥐어져 있게 된다. 더구나, 그 시나리오는 <strong>자동화된 단위 테스트라는 구체적이고 실행 가능한 형태로 구현</strong>되어 있다.</p>

<p>둘째, 테스트를 통과할 만큼만 코딩한다는 규칙을 잘 따라주면 <strong>설계를 간결하면서도 목적에 딱 맞도록 유지</strong>할 수 있다. 시나리오를 갖추지 못한 코드가 단 한줄도 없으므로 버릴게 하나도 없다. (우발적 복잡성은 코드 품질을 떨어뜨리는 가장 악명 높은 적이자 개발자 생산성을 갉아 먹는 주 요인이다. 우발적 복잡성이란 쓸데 없이 복잡한 것을 말한다. <strong>요구 조건을 그대로 만족하면서도 더 단순한 설계로 대체할 수 있다</strong>는 뜻이다.)</p>

<p>결함이나 빠진 기능을 명시하는 테스트, 테스트를 통과할 만큼의 코드만 작성한다는 규칙, 그리고 간결한 설계를 지향하는 철저한 리팩토링은 우발적 복잡성을 크게 줄여준다. (물론 만병 통치약이 될 수는 없다. <strong>최종 결과는 결국 프로그래머의 설계 감각과 경험에 크게 좌우</strong>되기 때문이다.)</p>

<h3>행위 주도 개발 (Behavior Driven Development)</h3>

<p>TDD를 하지 않는 이유 중 가장 흔한 것이 <strong>&ldquo;테스팅할 시간이 없어요&rdquo;</strong>와 <strong>&ldquo;테스트하기에 너무 복잡하고 힘든 코드&rdquo;</strong>라는 것이다. 테스트 우선 프로그래밍의 또 다른 장애물은 테스트 우선이라는 개념 그 자체다. 우리 대부분은 테스팅을 감촉적(tactile) 행위, 추상적이기보다는 구체적인 행위로 본다. <strong>우리는 경험적으로 존재하지 않는 어떤 것을 테스트하는 것이 가능하지 않다고 생각한다</strong>. 이 개념적인 프레임이 머릿속에 이미 자리잡은 일부 개발자들에게는 &lsquo;테스트 우선(testing first)'이라는 아이디어가 바보 같은 일로 여겨진다.</p>

<p>그러나 <strong>테스트를 작성하고 어떻게 테스트할 것인가 하는 관점이 아닌, 행위(behavior)에 대해 생각</strong>해 본다면 어떨까? 여기서 말하는 <strong>행위란 애플리케이션이 어떻게 동작'해야' 하는가, 즉 본질적으로 그것의 명세를 말하는 것</strong>이다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[C++ 11]]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/c-plus-plus-11/"/>
    <updated>2016-04-25T13:29:25+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/c-plus-plus-11</id>
    <content type="html"><![CDATA[<h2>C++11</h2>

<ol>
    <li>설계 목표</li>
    <li>C++ 핵심 언어 확장</li>
    <ol>
        <li>핵심 언어 런타임 성능 향상</li>
        <ol>
            <li><b><u>우측값 참조 및 이동 생성자</u></b></li>
            <li><b><code>constexpr</code> – 일반화된 상수 표현식</b></li>
            <li>Plain Old Data(POD) 정의 변경</li>
        </ol>
        <li>핵심 언어 빌드 타임 성능 향상</li>
        <ol>
            <li><b><code>extern</code> 템플릿</b></li>
        </ol>
        <li>핵심 언어 사용성 개선</li>
        <ol>
            <li><b>이니셜라이저 목록 <code>std::initializer_list&lt;T&gt;</code></b></li>
            <li><b>단일 형태 초기화 <code>{}</code></b></li>
            <li><b>타입 추론 <code>auto</code>, <code>decltype</code></b></li>
            <li><b>범위 기반 <code>for</code> 반복문</b></li>
            <li><b>람다 함수 및 표현식 <code>[]() -> T {}</b></li>
            <li><b>선택적 함수 문법 (반환 타입 지정)<code>auto () -> T {}</code></b></li>
            <li><b>생성자 위임</b></li>
            <li><b>명시적 <code>override</code> 및 <code>final</code></b></li>
            <li><b><code>nullptr</code></b></li>
            <li><b>강력한 형식의 열거형 <code>enum class</code></b></li>
            <li><b>오른쪽 꺽쇠 괄호 <code>>></code></b></li>
            <li>명시적 변환 연산자</li>
            <li>템플릿 별칭</li>
            <li>무제한 공용 구조체</li>
        </ol>
        <li>핵심 언어 기능성 개선</li>
        <ol>
            <li>Variadic 템플릿</li>
            <li>새로운 문자열 리터럴</li>
            <li>사용자 정의 리터럴</li>
            <li>멀티스레딩 메모리 모델</li>
            <li>스레드 로컬 저장소</li>
            <li><b>특수 멤버 함수에 붙는 <code>default</code> 및 <code>delete</code></b></li>
            <li><code>long long int</code> 타입</li>
            <li><code>static_assert</code></li>
            <li>확장된 <code>sizeof</code></li>
            <li>객체 정렬 조절 및 확인</li>
            <li>쓰레기 수집기 구현 허가</li>
            <li>특성 (Attributes)</li>
        </ol>
    </ol>
    <li>C++ 표준 라이브러리 변경</li>
    <ol>
        <li><b>표준 라이브러리 컴포넌트 업그레이드</b></li>
        <li>스레드 프로그래밍 편의</li>
        <li><b>튜플 타입</b></li>
        <li><b>해시 테이블</b></li>
        <li><b>정규 표현식</b></li>
        <li><b>다목적 스마트 포인터</b></li>
        <li>확장 가능한 랜덤 수 기능</li>
        <li>래퍼 참조</li>
        <li><b>함수 객체를 위한 다형성 래퍼</b></li>
        <li>메타프로그래밍을 위한 타입 trait</li>
        <li>함수 객체 반환 타입 계산을 위한 단일 형식 메소드</li>
    </ol>
</ol>


<h3><code>constexpr</code></h3>

<p>상수 표현식의 사용은 컴파일러에게 최적화의 기회를 준다. 컴파일러가 <code>3+4</code>와 같은 상수 표현식을 만나면 미리 계산해 놓고, 프로그램 내에 하드 코딩해 놓는다.</p>

<p>C++ 명세에서는 상수 표현식이어야만 하는 곳들이 몇 군데 있는데, 바로 배열의 정의와 열거형 선언이 그러하다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="nf">get_five</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">5</span><span class="p">;}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">some_value</span><span class="p">[</span><span class="n">get_five</span><span class="p">()</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span> <span class="c1">// Create an array of 12 integers. Ill-formed C++</span>
</span></code></pre></td></tr></table></div></figure>


<p>위에서 <code>get_five</code> 는 항상 <code>5</code>를 반환하여 의미론적으로 상수와 다를 바 없지만, 컴파일러는 이를 알 길이 없기 때문에 컴파일을 거부한다.</p>

<p>C++11에서는 다음과 같은 문법이 가능하다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">get_five</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">5</span><span class="p">;}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">some_value</span><span class="p">[</span><span class="n">get_five</span><span class="p">()</span> <span class="o">+</span> <span class="mi">7</span><span class="p">];</span> <span class="c1">// Create an array of 12 integers. Legal C++11</span>
</span></code></pre></td></tr></table></div></figure>


<p>컴파일러는 <code>get_five</code>가 컴파일 타임 상수임을 이해하고, 실제로 컴파일 타임 상수인지를 확인하게 된다.</p>

<p><code>constexpr</code>을 함수에 사용하게 되면 몇가지 제약 사항이 생긴다.
첫째로, <code>void</code>가 아닌 반환 타입을 가져야 한다. 둘째로, 함수 본체에서 변수나 새로운 타입을 정의할 수 없다. 셋째로, 함수 본체는 선언, null 문장만이 존재해야 하며, 딱 하나의 return 문만 가져야 한다.</p>

<p>C++11 이전에 변수의 값은 <code>const</code>로 선언되고, 상수 표현식으로 된 이니셜라이저를 가지며, 정수형 혹은 열거형 타입이어야만 상수 표현식으로 사용될 수 있었다. C++11에서는 <code>constexpr</code>가 붙으면, 정수형 혹은 열거형 타입이어야만 한다는 제약을 없앴다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">constexpr</span> <span class="kt">double</span> <span class="n">earth_gravitational_acceleration</span> <span class="o">=</span> <span class="mf">9.8</span><span class="p">;</span>
</span><span class='line'><span class="k">constexpr</span> <span class="kt">double</span> <span class="n">moon_gravitational_acceleration</span> <span class="o">=</span> <span class="n">earth_gravitational_acceleration</span> <span class="o">/</span> <span class="mf">6.0</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3><code>extern</code> 템플릿</h3>

<p>C++03에서는 하나의 번역 단위에서 완전하게 지정된 템플릿에 도달할 때마다 템플릿을 반드시 인스턴스화 해야 했다. 만약 똑같은 템플릿이 여러 번역 단위에서 인스턴스화 된다면 컴파일 타임이 상당히 길어질 수 있다. C++03에서 이를 막을 수 있는 방법이 없었기에, C++11에서는 새로이 extern 템플릿 선언을 도입하였는데, extern 데이터 선언과 비슷하다.
C++03에서는 아래의 문법으로 컴파일러에게 템플릿 인스턴스화를 강제할 수 있었는데:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span> <span class="k">class</span> <span class="nc">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11는 다음과 같은 문법을 제공한다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>이는 컴파일러에게 이 번역단위에서 템플릿을 인스턴스화 <strong>하지 말 것</strong>을 알려준다.</p>

<h3>이니셜라이저 목록</h3>

<p>C++03는 C로부터 이니셜라이저 목록을 계승받았다. 구조체나 배열을 멤버가 정의된 순서대로 중괄호로 쌓여진 목록으로 초기화 한다. 이니셜라이저 목록은 재귀적으로도 사용할 수 있어서, 다음과 같이도 가능하다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Object</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">first</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">second</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Object</span> <span class="n">scalar</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.43f</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span> <span class="c1">//One Object, with first=0.43f and second=10</span>
</span><span class='line'><span class="n">Object</span> <span class="n">anArray</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mf">13.4f</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mf">43.28f</span><span class="p">,</span> <span class="mi">29</span><span class="p">},</span> <span class="p">{</span><span class="mf">5.934f</span><span class="p">,</span> <span class="mi">17</span><span class="p">}</span> <span class="p">};</span> <span class="c1">//An array of three Objects</span>
</span></code></pre></td></tr></table></div></figure>


<p>이 방법은 정적 리스트나 구조체를 어떤 값으로 초기화할 때 아주 유용하다. C++는 생성자를 통해 객체를 초기화할 수도 있는데, 이는 이니셜라이저 목록만큼 편리하지는 않다. 하지만, C++03는 Plain Old Data (POD)에 대해서만 이니셜라이저 목록을 사용할 수 있다; C++11는 <code>std::vector</code>와 같은 표준 컨테이너 뿐만 아니라 모든 클래스에서도 이니셜라이저 목록을 사용할 수 있게 해준다.
<code>std::initializer_list</code>를 인자로 갖는 생성자나 함수를 만들어 두면, 이니셜라이저 목록을 인자로 받을 수 있다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">SequenceClass</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">SequenceClass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>위와 같이 만들면, 다음과 같이 사용할 수 있다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">SequenceClass</span> <span class="n">some_var</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>이러한 생성자를 이니셜라이저 목록 생성자라고 부르며, 이런 생성자를 갖는 클래스는 단일 형태 초기화를 사용할 수 있게 된다. (하단 참조)
<code>std::initializer_list&lt;&gt;</code> 클래스는 일급 C++11 표준 라이브러리 타입이며, C++11 컴파일러에서 <code>{}</code> 문법을 통해서만 정적으로 생성할 수 있다. 이 목록은 한번 생성되면 복사는 가능하지만, <code>copy-by-reference</code> 방식이다. 이니셜라이저 목록은 상수이므로 일단 한번 생성되면 값을 바꿀 수 없다.</p>

<p>이니셜라이저 목록이 타입이기 때문에, 클래스 생성자 뿐만 아니라 일반 함수에서도 쓰일 수 있다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="nf">function_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">function_name</span><span class="p">({</span><span class="mf">1.0f</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.45f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4f</span><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>또한 표준 컨테이너는 다음과 같은 방법으로 초기화될 수도 있다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;xyzzy&quot;</span><span class="p">,</span> <span class="s">&quot;plugh&quot;</span><span class="p">,</span> <span class="s">&quot;abracadabra&quot;</span> <span class="p">};</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">({</span> <span class="s">&quot;xyzzy&quot;</span><span class="p">,</span> <span class="s">&quot;plugh&quot;</span><span class="p">,</span> <span class="s">&quot;abracadabra&quot;</span> <span class="p">});</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span> <span class="s">&quot;xyzzy&quot;</span><span class="p">,</span> <span class="s">&quot;plugh&quot;</span><span class="p">,</span> <span class="s">&quot;abracadabra&quot;</span> <span class="p">};</span> <span class="c1">// see &quot;Uniform initialization&quot; below</span>
</span></code></pre></td></tr></table></div></figure>


<h3>단일 형태 초기화</h3>

<p>C++03는 초기화에 있어 몇가지 문제점을 가지고 있다. 초기화를 위한 여러가지 방법이 존재하며, 때때로 교환했을 때 다른 결과를 초래하기도 한다. 전통적인 초기화 문법은 함수 선언같이 보이므로, 컴파일러는 이 문법을 파싱하기 위해 추가적인 단계가 필요하다(파싱이 어려워진다는 뜻).
C++11 어느 객체에서나 동작하는 완전한 단일 형태의 초기화 문법을 제공한다. 이니셜라이저 목록 문법을 확장한 것이다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">BasicStruct</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">AltStruct</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">AltStruct</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">y_</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">private</span><span class="o">:</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">x_</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">y_</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">BasicStruct</span> <span class="n">var1</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">};</span>
</span><span class='line'><span class="n">AltStruct</span> <span class="n">var2</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mf">4.3</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>위의 코드는 모두가 예상한대로 동작할 것이다.</p>

<p>또한 다음과 같이 쓸 수도 있다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">IdString</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">identifier</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">IdString</span> <span class="nf">get_string</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">};</span> <span class="c1">// 굳이 타입을 적어주지 않아도 됨.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>단일 형태 초기화는 생성자 문법을 대체하지는 않는다. 생성자 문법이 때때로 필요하기 때문이다. 예를 들어보자. 만약 클래스가 이니셜라이저 목록 생성자를 가지고 있다면, (<code>TypeName(initializer_list&lt;SomeType&gt;);</code>), 다른 형태의 생성자보다 우선시된다. C++11의 <code>std::vector</code>는 이니셜라이저 목록 생성자를 가지고 있다. 그러므로 아래 코드는:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">the_vec</span><span class="p">{</span><span class="mi">4</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>이니셜라이저 목록 생성자를 호출할 것이다. 벡터는 원소 <code>4</code> 한 개를 갖게 될 것이다. 벡터의 초기 사이즈를 결정하는 생성자 호출이 아니란 말이다. 벡터의 초기 사이즈를 지정하고 싶다면, 일반적인 생성자 문법으로 벡터를 생성해야 한다.</p>

<h3>타입 추론</h3>

<p>C++03 (그리고 C)에서 변수를 사용하려면, 타입이 명시적으로 지정되어야 한다. 반면, 템플릿 타입과 템플릿 메타프로그래밍 테크닉의 출현과 함께 무언가의 타입(특히 잘 정의된 함수의 반환 값)은 쉽게 표현되지 않을 수 있다. 따라서, 중간 값을 변수에 담기는 어려우며, 아마 주어진 메타프로그래밍 라이브러리 내부에 대한 지식을 알아야 할지도 모른다.
C++11에서는 두가지 방법으로 이를 완화시킬 수 있다.
첫째로, 명시적 초기화와 함께 정의된 변수에 <code>auto</code> 키워드를 사용할 수 있다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">some_strange_callable_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">some_function</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">some_object</span><span class="p">);</span>
</span><span class='line'><span class="k">auto</span> <span class="n">other_variable</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>some_strange_callable_type</code>의 타입은 <code>std::bind</code> 템플릿 함수가 반환하는 타입으로 정해진다. 사용자에게는 쉽지 않은 타입 결정을, 컴파일러는 절차적인 의미론 분석을 통해 쉽게 결정할 수 있다.
<code>other_variable</code>는 사용자에게나 컴파일러에게나 쉽게 타입이 결정된다. 이 타입은 <code>int</code>이며 정수 리터럴 <code>5</code>과 같은 타입이다.
둘째로, <code>decltype</code> 키워드로 표현식의 타입을 컴파일 타임에 결정할 수 있도록 한다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">some_int</span><span class="p">;</span>
</span><span class='line'><span class="k">decltype</span><span class="p">(</span><span class="n">some_int</span><span class="p">)</span> <span class="n">other_integer_variable</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>auto</code> 변수의 타입은 컴파일러만 알고 있기 때문에 <code>decltype</code> 키워드는 <code>auto</code> 키워드와 사용될 때 더욱 유용하다. 연산자 오버로딩이나 특화된 타입을 많이 사용하는 표현식에서 <code>decltype</code>이 매우 유용하게 사용될 수 있다.
<code>auto</code>는 또한 코드의 장황함을 줄여주는데 도움을 준다. 예를 들어, 다음과 같이 쓰는 대신</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">myvec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">myvec</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">itr</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>다음과 같이 줄여쓸 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">myvec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">myvec</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">itr</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>&ldquo;myvec"은 begin/end 반복자가 구현되어 있기 때문에 다음과 같이 좀더 줄여 쓸 수 있다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">myvec</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>컨테이너를 중첩시키고 <code>typedef</code>를 통한 코드의 양 줄이기를 썼을 때 더욱 커진다(? 해석 불가).</p>

<p><code>decltype</code>에 의해 지정된 타입은 <code>auto</code>에 의해 추론된 타입과 다를 수도 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>        <span class="c1">// a has type int</span>
</span><span class='line'>    <span class="k">decltype</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// b has type const int&amp;, the return type of</span>
</span><span class='line'>                          <span class="c1">//   std::vector&lt;int&gt;::operator[](size_type) const</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>           <span class="c1">// c has type int</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>           <span class="c1">// d has type int</span>
</span><span class='line'>    <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span>        <span class="c1">// e has type int, the type of the entity named by c</span>
</span><span class='line'>    <span class="k">decltype</span><span class="p">((</span><span class="n">c</span><span class="p">))</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">// f has type int&amp;, because (c) is an lvalue</span>
</span><span class='line'>    <span class="k">decltype</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">g</span><span class="p">;</span>        <span class="c1">// g has type int, because 0 is an rvalue</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>범위 기반 <code>for</code> 반복문</h3>

<p>C++11는 요소의 범위를 쉽게 순회할 수 있는 <code>for</code> 문법을 확장하였다:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span><span class='line'><span class="c1">// double the value of each element in my_array:</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="nl">x</span> <span class="p">:</span> <span class="n">my_array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// similar but also using type inference for array elements</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">x</span> <span class="p">:</span> <span class="n">my_array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>이 형식의 <code>for</code>문은 &ldquo;범위 기반 for"로 불리며(주로 다른 언어에서는 "foreach"라고 불림), 리스트의 각 요소를 순회한다. C-스타일의 배열, 이니셜라이저 목록, 또는 반복자를 반환하는 <code>begin()</code> 과 <code>end()</code> 함수가 정의된 모든 타입에서 동작하며, 또한 begin/end 쌍을 가지고 있는 모든 표준 컨테이너에서도 잘 동작한다.</p>

<h3>람다 함수 및 표현식</h3>

<p>C++11은 람다라고 불리는 익명 함수를 만들 수 있다. 다음과 같은 형태이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">[</span><span class="n">capture</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">return_type</span> <span class="p">{</span> <span class="n">function_body</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>다음은 람다 함수의 예:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11은 클로져도 지원한다. 클로져는 람다 표현식에서 대괄호인 <code>[</code>와 <code>]</code> 사이에 정의된다. 값에 의한 캡쳐와 참조에 의한 캡쳐를 지원한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">[]</span>        <span class="c1">//no variables defined. Attempting to use any external variables in the lambda is an error.</span>
</span><span class='line'><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">]</span>   <span class="c1">//x is captured by value, y is captured by reference</span>
</span><span class='line'><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>       <span class="c1">//any external variable is implicitly captured by reference if used</span>
</span><span class='line'><span class="p">[</span><span class="o">=</span><span class="p">]</span>       <span class="c1">//any external variable is implicitly captured by value if used</span>
</span><span class='line'><span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>    <span class="c1">//x is explicitly captured by value. Other variables will be captured by reference</span>
</span><span class='line'><span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">]</span>   <span class="c1">//z is explicitly captured by reference. Other variables will be captured by value</span>
</span></code></pre></td></tr></table></div></figure>


<p>값에 의한 캡쳐 변수는 기본적으로 상수이다. 매개 변수 목록 다음에 <code>mutable</code> 키워드를 추가하면 매개 변수 목록이 비상수가 된다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">[</span><span class="n">capture</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="n">return_type</span> <span class="p">{</span> <span class="n">function_body</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>다음 두 예시는 람다 표현식의 사용법을 보여준다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">some_list</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">some_list</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">some_list</span><span class="p">),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">total</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>이 예는 벡터에 들어있는 모든 요소의 합계를 구한다. <code>total</code> 변수가 람다 함수의 내부로 캡쳐되어 사용된다. <code>total</code> 변수는 스택 변수에 대한 참조이므로 값을 변경할 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">some_list</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">some_list</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">some_list</span><span class="p">),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="k">this</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">total</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">value</span> <span class="o">*</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">some_func</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>total</code>은 참조로, <code>value</code>는 복사로 전달했다.
<code>this</code>의 캡쳐는 특별한 의미를 갖는데, 참조로는 캡쳐할 수 없고 값으로만 캡쳐할 수 있다. <code>this</code>는 람다를 감싸고 있는 가장 가까운 함수가 비정적 멤버 함수일 때에만 캡쳐할 수 있다. 람다는 protected/private 멤버에 대해 람다가 정의된 멤버 함수와 똑같은 접근 권한을 가진다.
If this is captured, either explicitly or implicitly, then the scope of the enclosed class members is also tested. Accessing members of this does not require explicit use of this-> syntax.
The specific internal implementation can vary, but the expectation is that a lambda function that captures everything by reference will store the actual stack pointer of the function it is created in, rather than individual references to stack variables. However, because most lambda functions are small and local in scope, they are likely candidates for inlining, and thus will not need any additional storage for references.
If a closure object containing references to local variables is invoked after the innermost block scope of its creation, the behaviour is undefined.
Lambda functions are function objects of an implementation-dependent type; this type&rsquo;s name is only available to the compiler. If the user wishes to take a lambda function as a parameter, the type must be a template type, or they must create a std::function or a similar object to capture the lambda value. The use of the auto keyword can help store the lambda function,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">my_lambda_func</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</span><span class='line'><span class="k">auto</span> <span class="n">my_onheap_lambda_func</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>다음은 람다 함수를 변수, 배열, 벡터에 저장하고, 함수의 매개 변수로 람다를 전달하는 예시이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'><span class="cp">#include &lt;vector&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">double</span> <span class="nf">eval</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span> <span class="o">&lt;</span><span class="kt">double</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f0</span>    <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="mi">1</span><span class="p">;};</span>
</span><span class='line'>    <span class="k">auto</span>                          <span class="n">f1</span>    <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="p">;};</span>
</span><span class='line'>    <span class="k">decltype</span><span class="p">(</span><span class="n">f0</span><span class="p">)</span>                  <span class="n">fa</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">,[](</span><span class="kt">double</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;}};</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">f0</span><span class="p">)</span><span class="o">&gt;</span>     <span class="n">fv</span>    <span class="o">=</span> <span class="p">{</span><span class="n">f0</span><span class="p">,</span><span class="n">f1</span><span class="p">};</span>
</span><span class='line'>    <span class="n">fv</span><span class="p">.</span><span class="n">push_back</span>                  <span class="p">([](</span><span class="kt">double</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;});</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">fv</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fv</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fa</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">f</span> <span class="p">:</span> <span class="n">fv</span><span class="p">)</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">f</span> <span class="p">:</span> <span class="n">fa</span><span class="p">)</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">f0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">eval</span><span class="p">([](</span><span class="kt">double</span> <span class="n">x</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;})</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>빈 캡쳐 리스트로 된 람다 표현식은 같은 타입의 함수 포인터로 암묵적으로 변경할 수 있다. 따라서 다음이 가능하다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">auto</span> <span class="n">a_lambda_func</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">func_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">a_lambda_func</span><span class="p">;</span>
</span><span class='line'><span class="n">func_ptr</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//calls the lambda.</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[C++ 11] Delegating Constructors]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/c-plus-plus-11-delegating-constructors/"/>
    <updated>2016-04-25T13:29:10+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/c-plus-plus-11-delegating-constructors</id>
    <content type="html"><![CDATA[<h3>생성자 위임 (C++11)</h3>

<p>아래와 같은 클래스를 가정해보자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">_x</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">_y</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>여기에서는 데이터 멤버 수가 적기 때문에 크게 문제될 것이 없어 보이지만, 데이터 멤버가 늘어나면 날수록 멤버 초기화 리스트에 보이는 멤버들 수는 기하 급수적으로 늘어날 것이다.</p>

<p>C++03 에서는 아래와 같은 방법들로 이를 해결했었다.</p>

<ol>
<li>데이터 멤버에 기본 값을 넣을 수 있는 경우에. 기본 인자를 설정하여 여러 버전의 생성자를 만드는 방법</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// Foo(char)와 Foo(char, int)</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>대입으로도 초기화가 가능한 데이터 멤버들을 별도의 함수로 빼내어(대게 <code>private</code> 함수) 초기화를 시키는 방법</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>   <span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'>   <span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>   <span class="p">...</span>
</span><span class='line'>
</span><span class='line'> <span class="k">private</span><span class="o">:</span>
</span><span class='line'>   <span class="p">...</span>
</span><span class='line'>   <span class="kt">void</span> <span class="n">construct</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'> <span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="n">construct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>     <span class="p">...</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="n">construct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'>     <span class="p">...</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="kt">void</span> <span class="n">Foo</span><span class="o">::</span><span class="n">construct</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'> <span class="p">{</span>
</span><span class='line'>     <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>     <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'>     <span class="p">...</span>
</span><span class='line'> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>1번의 방법이 깔끔하긴 하지만 인자의 순서에 신경을 써야 한다는 단점이 있다. 기본 인자들은 마지막에 넣어주어야 하기 때문이다.</p>

<p>2번은 코드 중복을 피할 수는 있지만, 효율성을 잃게 된다.</p>

<p>C++11에서는 아주 멋지게 이를 해결할 방법이 존재한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 생성자 위임</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>위처럼 생성자 위임을 통해 다른 버전의 생성자를 호출하는 것이 가능해진다.</p>

<p>또한 아래와 같은 방법도 가능하다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">explicit</span> <span class="n">Foo</span><span class="p">(</span><span class="kt">char</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>기본 생성자를 호출하는 경우에도 <code>_x</code>는 <code>0</code>으로 초기화될 것이다. 또한 <code>Foo(char)</code> 생성자는 효율성을 위해 <code>_x</code>의 초기화를 두번 수행하지 않고 한번만 수행한다. (<code>Foo(char)</code> 생성자에 <code>explicit</code> 키워드를 붙이는 이유는 [Effective C++ 항목 24] 참조)</p>

<p>기본 클래스의 생성자로부터 생성자를 위임하고자 할 경우에는 다음과 같은 방법을 사용할 수도 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">BaseClass</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">BaseClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">DerivedClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseClass</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">using</span> <span class="n">BaseClass</span><span class="o">::</span><span class="n">BaseClass</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>using</code> 키워드를 사용하여 <code>DerivedClass</code>에서 <code>BaseClass</code>의 생성자를 사용하고 있다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Exceptional C++ Style] Item 1. vector의 올바른 용법과 잘못된 용법]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/exceptional-c-plus-plus-style-item-1/"/>
    <updated>2016-04-25T13:26:14+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/exceptional-c-plus-plus-style-item-1</id>
    <content type="html"><![CDATA[<p>&lt;난이도 4></p>

<h3>질문</h3>

<blockquote><p>[1] <code>vector&lt;int&gt; v</code> 가 주어졌다고 할 때, 아래의 줄 A와 B의 차이는 무엇일까?</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>    <span class="c1">// A</span>
</span><span class='line'>    <span class="n">v</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// B</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>[2] 다음 코드를 고찰하라.</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">v</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>이 코드를 비평하라. 스타일과 정확성 모두를 고려할 것.</p>

<h3>해답</h3>

<h4>벡터 요소의 접근</h4>

<p>[1] 번의 질문에서 <code>v</code>가 비어 있지 않다면 A와 B는 아무 차이도 없다. 하지만, <code>v</code>가 비어 있다면 줄 B는 <code>std::out_of_range</code> 예외를 던지는 것이 보장되나, 줄 A에 대해서는 어떠한 규정도 없다.</p>

<p>벡터 안의 요소에 접근하는 방법은 두가지인데, 하나는 <code>vector&lt;T&gt;::at</code>이고, 다른 하나는 <code>vector&lt;T&gt;::operator[]</code>이다. 전자는 범위 점검을 반드시 하도록 규정되어 있고, 후자는 범위 점검이 허용되긴 하나 필수 조건은 아니다. 표준 라이브러리 구현에 따라 다르다.</p>

<p>그러나 일반적으로 <code>operator[]</code>가 범위 점검을 하지 않도록 구현하는 것은 <code>vector</code>가 내장 배열을 대체할 목적으로 나왔기 때문이다. <code>vector</code>는 내장 배열만큼 효율적이어야 하기 때문에 내장 배열의 접근 연산자 <code>[]</code>와 같이 범위 점검을 하지 않는다. 따라서 존재하지 않는 요소에 대한 접근은 <code>미정의 동작</code>이다.</p>

<p>C++의 철학중 <strong>&ldquo;사용하지 않는 것에 대해서는 지불하지 않는다&rdquo;</strong>가 깔린 것이다.</p>

<h4>벡터 키우기</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>위의 단언문은 두 가지 문제점을 가지고 있는데, 첫번째는 이 단언문이 실패할 수 있다는 것이다. <code>reserve</code> 호출에 의해서 <code>vector</code>의 <code>capacity</code>는 적어도 2가 된다. 그러나 이 값이 2보다 클 수도 있다. <code>vector</code>의 크기는 내부적으로 지수적으로 증가하게 되어 있다. 따라서 단언문을 <code>assert(v.capacity() &gt;= 2)</code>와 같이 바꿔주어야 한다. 두번째는 이 단언문이 필요없다는 것인데, <code>reserve</code> 호출이 이미 해당 단언문을 보장해주기 때문이다. 표준 라이브러리를 의심하고 있는 경우가 아니라면 이 단언문은 필요가 없다.</p>

<p>벡터에 값을 집어 넣는 아래의 두줄은 명백한 실수이지만, 표준 라이브러리 구현에 따라서는 아무런 오류를 내지 않을 수 있다는 점에서 찾기 어려운 버그의 원인이 된다.</p>

<p><code>size</code>(<code>resize</code>와 짝을 이룸)와 <code>capacity</code>(<code>reserve</code>와 짝을 이룸) 사이에는 다음과 같은 차이가 존재한다.</p>

<ul>
<li><p><code>size</code>, <code>resize</code></p>

<ul>
<li><code>size</code>: 컨테이너 안에 실제로 들어 있는 요소들의 개수</li>
<li><code>resize</code>: 컨테이너 끝에 요소들을 추가하거나 제거함으로써 컨테이너의 실제 요소 개수를 변경</li>
<li><code>size</code>는 모든 표준 컨테이너에 존재하지만, <code>resize</code>는 <code>list</code>, <code>vector</code>, <code>deque</code>에만 존재</li>
</ul>
</li>
<li><p><code>capacity</code>, <code>reserve</code></p>

<ul>
<li><code>capacity</code>: <code>vector</code>가 더 많은 공간을 할당하지 않고도 담을 수 있는 잠재적인 요소들의 개수</li>
<li><code>reserve</code>: 지정된 공간을 담는 데 필요한 내부 버퍼의 크기를 키움(줄이는 경우는 없음)</li>
<li> 두 함수 모두 <code>vector</code>에만 존재</li>
</ul>
</li>
</ul>


<p>위 예제의 경우, <code>reserve</code>의 호출로 <code>capacity</code>는 2 이상이 되었지만, <code>v</code>에 요소들을 추가하지는 않았기 때문에 실제 요소의 개수는 0 이다. <code>v</code>는 단지 요소들을 담을 공간만을 가지고 있을 뿐이다.</p>

<p><code>operator[]</code>가 요청된 요소를 알아서 추가해주면 좋겠다고 생각하겠지만, 그런 것을 허용한다면 벡터 안에 &ldquo;구멍"들이 생겨버린다. 다음 예를 보자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">v</span><span class="p">[</span><span class="mi">99</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// 오류이지만 이 논의를 위해 이런 것이 허용된다고 가정하자.</span>
</span><span class='line'><span class="c1">// v[0..98]에는 무엇이 있을까?</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>operator[]</code> 표현은 단지 내부 버퍼의 참조를 돌려줄 뿐이다. 표준 라이브러리는 프로그래머가 잘못된 코드를 쓰지 않을 정도의 지식을 가지고 있다고 가정하기 때문이다. 범위 점검을 수행하길 원한다면 <code>operator[]</code> 대신 <code>v.at(0)</code>을 사용하자.</p>

<p>만일 <code>v.reserve(2)</code> 대신 <code>v.resize(2)</code>를 수행했다면 <code>v[0] = 1; v[1] = 2;</code>는 아무런 문제가 없었을 것이다. 또는 <code>v.push_back(1); v.push_back(2);</code>를 사용하는 경우도 마찬가지다. <code>push_back()</code>은 컨테이너의 끝에 요소들을 항상 안전하게 추가하는 방법이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>이 루프는 아무것도 출력하지 않는다. <code>v</code>는 여전히 비어있기 때문이다. 이 루프 자체에는 별 오류가 없다. 그러나 코드 리뷰 상으로는 몇가지 스타일상의 문제점들이 존재하는데, 다음과 같다.</p>

<ol>
<li><p><strong><code>const</code> 정확성을 최대한 지킬 것.</strong>
반복자는 <code>vector</code>의 내용을 변경하지 않으므로 <code>const_iterator</code>이어야 한다.</p></li>
<li><p><strong>반복자들을 비교할 때에는 <code>&lt;</code> 대신 <code>!=</code>를 선호할 것.</strong>
<code>vector&lt;T&gt;::iterator</code>는 임의 접근 반복자이므로, 위의 예에서는 별 문제가 없다. 그러나 <code>&lt;</code>는 임의 접근 반복자에만 작동하는 반면 <code>!=</code>는 다른 종류의 반복자들에게도 작동하므로, <code>&lt;</code>가 반드시 필요한 경우가 아니라면 항상 <code>!=</code>를 사용하는 습관을 들이는 것이 좋다. (또한 <code>!=</code>는 나중에 어떤 이유로 다른 컨테이너로 전환할 때 더 편하다. 예를 들어 <code>std::list</code>의 반복자는 양방향 반복자일 뿐이므로 <code>&lt;</code>를 지원하지 않는다.)</p></li>
<li><p><strong>후위 <code>--</code>,<code>++</code> 대신 전위 <code>--</code>,<code>++</code>를 선호할 것.</strong>
루프에서 i의 이전 값이 필요한 경우가 아니라면 항상 <code>i++</code> 대신 <code>++i</code>를 사용하는 습관을 들이자. 다만, <code>v[i++]</code>처럼 <code>i</code>번째 요소에 접근한 후에 루프 카운터를 증가시키는 경우라면 후위 표기가 더 자연스럽다.</p></li>
<li><p><strong>불필요한 재계산을 피할 것.</strong>
이 예의 경우 <code>v.end()</code>가 돌려준 값은 루프 도중에 변하지 않으므로, 매 반복마다 컨테이너의 끝을 재계산하는 대신 루프를 시작하기 전에 미리 계산해 두는 게 낫다.</p></li>
<li><p><strong><code>endl</code> 보다는 <code>'\n'</code>을 선호할 것.</strong>
<code>endl</code>은 스트림의 내부 출력 버퍼를 비우도록 강제한다. 스트림이 버퍼링되며 매번 버퍼를 밀어낼 필요가 없다면, 루프가 끝났을 때 한번만 비우게 하는 게 프로그램의 성능에 도움이 된다.</p></li>
<li><p><strong>루프를 직접 작성하기보다는 표준 라이브러리의 copy와 for_each를 재사용할 것. 표준 라이브러리의 기능을 사용하는 것이 쉽고 깔끔하기 때문이다. 다만, 이는 취향의 문제일 수 있다.</strong>
루프 본체가 단순한 경우라면 <code>copy</code>와 <code>for_each</code> 쪽이 직접 짠 코드보다 가독성이 더 좋을 수 있다. 그러나 루프 본체가 좀 복잡한 경우라면 루프 본체를 함수자(functor)들로 분해해야 하기 때문에 코드가 매우 지저분해질 수 있다(c++11에서는 람다 표현식으로 해결 가능).</p></li>
</ol>


<p>위의 루프는 다음처럼 바꿀 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>위의 코드를 사용했을 때에는 <code>!=</code>, <code>전위 ++</code>, <code>end()</code>, <code>endl</code>에 대한 실수는 애초에 사라진다. 내부적으로 copy 자체가 그런 것들을 처리하기 때문이다. 만약 스트림을 매번 비워야 할 경우는 루프 본체를 직접 짜는 수 밖에 없다.</p>

<p>(c++11에서는 간단하게 <code>const_iterator</code> 문제도 해결할 수 있는 방법이 있는데, <code>cbegin()</code>과 <code>cend()</code>를 사용하면 된다.)</p>

<p>다음으로 출력 코드를 보자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>위의 결과로 <code>1</code>이 출력될 수도 있다. 이는 프로그램이 잘못된 방식으로 메모리에 뭔가를 썼지만 그게 즉시 문제를 일으키지는 않았기 때문인데, 사실 그게 더 골치 아픈 문제이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>앞에서와 마찬가지로 이 단언문 역시 <code>&gt;=</code>를 사용해야 하며, 게다가 불필요하다.
그리고 <code>v[0]</code>을 출력하면 <code>0</code>이 나온다.</p>

<p><code>reserve(100)</code> 때문에 <code>v</code>의 내부 버퍼가 실제로 재할당 되었다고 가정하자(즉 최초의 <code>reserve(2)</code>가 벡터의 용량을 100 이상으로 증가시키지 않았다고 하자). 그런 경우는 이미 들어있던 요소들만을 새 버퍼에 복사할 것이다. 그런데 <code>v</code>에는 아무 것도 들어있지 않았다. 그래서 새 버퍼는 그냥 정의되지 않은 값(흔히 <code>0</code>)들만 가지게 된다.</p>

<p>이 이후의 코드들도 앞에서 설명한 이유와 마찬가지로 잘못되었으므로 바로 잡아야 한다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Effective C++] Item 7. 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-7/"/>
    <updated>2016-04-25T13:17:34+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-7</id>
    <content type="html"><![CDATA[<p>다음과 같은 다형성을 가진 클래스를 가정하자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">TimeKeeper</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">TimeKeeper</span><span class="p">();</span>
</span><span class='line'>    <span class="o">~</span><span class="n">TimeKeeper</span><span class="p">();</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">AtomicClock</span><span class="o">:</span> <span class="k">public</span> <span class="n">TimeKeeper</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">WaterClock</span><span class="o">:</span> <span class="k">public</span> <span class="n">TimeKeeper</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span><span class='line'><span class="k">class</span> <span class="nc">WristWatch</span><span class="o">:</span> <span class="k">public</span> <span class="n">TimeKeeper</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>사용자는 이 클래스를 이용하여 시간 계산을 하고 싶을 것이다. 그러나 이 시계가 어떤 시계인지에 대한 관심은 없다. 그렇다면 다음과 같이 팩토리 함수를 만들어 두고 사용하면 좋을 것이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">TimeKeeper</span><span class="o">*</span> <span class="nf">getTimeKeeper</span><span class="p">();</span> <span class="c1">// TimeKeeper의 파생 클래스로부터 생성되는 객체의 포인터를 반환</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">TimeKeeper</span> <span class="o">*</span><span class="n">ptk</span> <span class="o">=</span> <span class="n">getTimeKeeper</span><span class="p">();</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">ptk</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">TimeKeeper</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">TimeKeeper</span><span class="p">();</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="o">~</span><span class="n">TimeKeeper</span><span class="p">();</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">TimeKeeper</span> <span class="o">*</span><span class="n">ptk</span> <span class="o">=</span> <span class="n">getTimeKeeper</span><span class="p">();</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">ptk</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">xCoord</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yCoord</span><span class="p">);</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Point</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">SpecialString</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">SpecialString</span> <span class="o">*</span><span class="n">pss</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpecialString</span><span class="p">(</span><span class="s">&quot;Impending Doom&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">ps</span> <span class="o">=</span> <span class="n">pss</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">AWOV</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">virtual</span> <span class="o">~</span><span class="n">AWOV</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">AWOV</span><span class="o">::~</span><span class="n">AWOV</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Effective C++] Item 6. 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-6/"/>
    <updated>2016-04-25T13:17:32+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-6</id>
    <content type="html"><![CDATA[<h3>객체 복사 막기</h3>

<p>부동산과 관련된 다음과 같은 클래스가 있다고 가정해보자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">HomeForSale</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>모든 자산은 세상에 하나 밖에 없기 때문에 위 클래스로 만들어지는 객체는 복사가 불가능하게 해야한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">HomeForSale</span> <span class="n">home1</span><span class="p">;</span>
</span><span class='line'><span class="n">HomeForSale</span> <span class="n">home2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">HomeForSale</span> <span class="nf">home3</span><span class="p">(</span><span class="n">home1</span><span class="p">);</span> <span class="c1">// home1을 복사하려 한다.</span>
</span><span class='line'>
</span><span class='line'><span class="n">home1</span> <span class="o">=</span> <span class="n">home2</span><span class="p">;</span> <span class="c1">// home2를 복사하려 한다.</span>
</span></code></pre></td></tr></table></div></figure>


<p>일반적으로 어떠한 기능을 막고 싶다면, 그런 기능을 지원하는 함수를 선언하지 않으면 된다. 그러나 <strong>복사 생성자와 복사 대입 연산자는 컴파일러가 자동으로 만들어 내기 때문에</strong>(항목 5 참조) 이런 방법이 통하지 않는다.</p>

<p>그렇다면 어떻게 해야 할까? 바로 컴파일러가 자동 생성하는 함수는 <code>public</code>이 되기 때문에 <code>private</code>으로 미리 만들어 버리면 된다. 일단 이들을 만들어 두기만 한다면, 컴파일러는 절대로 자동 생성을 하지 않는다.</p>

<p>여기까지만 하면 될까? 아니다. 약간 부족하다. <strong><code>private</code> 멤버 함수는 그 클래스의 멤버 함수와 <code>friend</code> 함수가 호출할 수 있다</strong>는 사실이 떡하니 버티고 있다. 이것까지 막으려면 어떻게 하는 것이 좋을까? 바로 <strong>&lsquo;정의'를 일부로 하지 않으면 된다</strong>. 어쩌다 실수로 복사 생성자나 복사 대입 연산자를 호출했다면, 링크 시점에 '정의되지 않은 함수'라는 에러를 보게 될테니 말이다. 이 꼼수는 하나의 기법으로 굳어져 표준 라이브러리인 <code>iostream</code>의 <code>ios_base</code>, <code>basic_ios</code>등에서도 쓰이고 있다고 한다.</p>

<p>자, 그럼 복사가 불가능한 버전의 <code>HomeForSale</code>을 보자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">HomeForSale</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">HomeForSale</span><span class="p">(</span><span class="k">const</span> <span class="n">HomeForSale</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 선언만 달랑 있다.</span>
</span><span class='line'>    <span class="n">HomeForSale</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HomeForSale</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 마찬가지</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>매개 변수 이름이 빠져 있지만, 이는 필수 사항이 아니며, 매개 변수 이름을 선언한다해도 사용할 일이 없으니 뺐다.</p>

<p>이제 사용자가 <code>HomeForSale</code> 객체를 복사하려 한다면 컴파일 시점 에러를 보게 될것이고, 여러분이 깜빡하고 <code>HomeForSale</code>의 멤버 함수 혹은 <code>friend</code> 함수 안에서 객체를 복사하려 한다면 링크 시점 에러를 보게 될 것이다.</p>

<h3>링크 시점 에러를 컴파일 시점 에러로 바꾸기</h3>

<p>추가로 링크 시점 에러를 컴파일 시점 에러로 옮길 수도 있다. 에러는 나중에 발견되는 것보다 미리 발견되는 것이 더 좋기 때문에 이 방법을 추천한다. 바로 <strong>복사 불가 속성을 가지는 기반 클래스로부터 상속을 받는 방법</strong>이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Uncopyable</span> <span class="p">{</span>
</span><span class='line'><span class="k">protected</span><span class="o">:</span> <span class="c1">// 파생된 클래스에 대해</span>
</span><span class='line'>    <span class="n">Uncopyable</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 생성과</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Uncopyable</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 소멸을 허용</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Uncopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">Uncopyable</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 하지만 복사는 방지</span>
</span><span class='line'>    <span class="n">Uncopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Uncopyable</span><span class="o">&amp;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>이제 <code>HomeForSale</code>을 다음과 같이 바꿔주자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">HomeForSale</span><span class="o">:</span> <span class="k">private</span> <span class="n">Uncopyable</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>HomeForSale</code> 객체의 복사를 시도할 때, 컴파일러는 복사 생성자 혹은 복사 대입 연산자를 생성하려고 할 것이다. 그러나 <strong>컴파일러가 자동 생성한 복사 생성자나 복사 대입 연산자는 기반 클래스의 복사 생성자나 복사 대입 연산자를 먼저 호출해야 하지만</strong>,  해당 함수들이 <code>private</code>으로 선언되어 있기 때문에 생성이 되지 않으며, 컴파일 에러가 발생한다.</p>

<p>여기서 기술적으로 미묘한 몇가지 사항을 짚고 넘어가자면, 우선 <code>Uncopyable</code>로부터의 상속은 <code>public</code> 상속일 필요가 없다(항목 32 및 39 참조). 그리고 <code>Uncopyable</code>의 소멸자는 가상 소멸자가 아니어도 된다(항목 7 참조). 또한 <code>Uncopyable</code> 클래스는 데이터 멤버가 전혀 없기 때문에 <strong>공백 기반클래스 최적화(EBO: Empty Base Optimization)</strong>(항목 39 참조) 기법을 쓸 여지가 생기는데, <code>Uncopyable</code>은 기반 클래스이기 때문에 이 기법을 사용하면 다중 상속(항목 40 참조)으로 갈 가능성이 있다. 그러나, 다중 상속시에는 EBO 기법이 돌아가지 못할 때가 종종 있으니 이런 미묘한 부분은 대강 무시하고 넘어가자. 또한 <em>부스트(boost)</em> 라이브러리에는 <code>Uncopyable</code>와 똑같은 구실을 하는 <code>noncopyable</code>이라는 클래스가 있는데, 이 클래스를 사용해도 된다.</p>

<blockquote><ul>
<li>컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 멤버 함수를 <code>private</code>으로 선언한 후에 구현은 하지 않은 채로 두자. <code>Uncopyable</code>과 비슷한 기반 클래스를 상속해서 사용하는 것도 한 방법이다.</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Effective C++] Item 5. C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-5/"/>
    <updated>2016-04-25T13:17:31+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-5</id>
    <content type="html"><![CDATA[<h3>컴파일러가 자동으로 만들어내는 함수</h3>

<p>비어 있는 클래스일지라도 컴파일러가 저절로 선언해 주는 멤버 함수들이 있다. 바로 <strong>복사 생성자</strong>, <strong>복사 대입 연산자</strong>, 그리고 <strong>소멸자</strong>이다. 만약 생성자 조차도 선언되어 있지 않으면 <strong>기본 생성자</strong>까지 컴파일러가 만들어 낸다. 이들은 모두 기본형으로 <code>public</code>이며 <code>inline</code> 함수로 만들어 진다(항목 30 참조).</p>

<p>따라서 다음과 같은 클래스는</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Empty</span> <span class="p">{</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Empty</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">Empty</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>                            <span class="c1">// 기본 생성자</span>
</span><span class='line'>    <span class="n">Empty</span><span class="p">(</span><span class="k">const</span> <span class="n">Empty</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>            <span class="c1">// 복사 생성자</span>
</span><span class='line'>    <span class="o">~</span><span class="n">Empty</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>                           <span class="c1">// 소멸자</span>
</span><span class='line'>    <span class="n">Empty</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Empty</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// 복사 대입 연산자</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>위의 코드와 크게 다르지 않다. 그렇다고 컴파일러가 무턱대고 만들어 내는 것은 아니고, 아래와 같이 사용될 때 필요에 의해 만들어낸다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Empty</span> <span class="n">e1</span><span class="p">;</span> <span class="c1">// 기본 생성자, 소멸자</span>
</span><span class='line'><span class="n">Empty</span> <span class="nf">e2</span><span class="p">(</span><span class="n">e1</span><span class="p">);</span> <span class="c1">// 복사 생성자</span>
</span><span class='line'><span class="n">e2</span> <span class="o">=</span> <span class="n">e1</span><span class="p">;</span> <span class="c1">// 복사 대입 연산자</span>
</span></code></pre></td></tr></table></div></figure>


<p>기본 생성자/소멸자가 생성될 때에는 기반 클래스 및 비정적 데이터 멤버의 생성자/소멸자가 자동으로 호출된다. 이 때, <strong>이 클래스가 상속한 기반 클래스의 소멸자가 가상 함수로 선언되어 있지 않으면, 비가상 소멸자로 만들어 진다(항목 7 참조)</strong>.</p>

<p>컴파일러가 만들어낸 복사 생성자와 복사 대입 연산자는 원본 객체의 비정적 데이터를 사본 객체로 복사한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">NamedObject</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">NamedObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NamedObject</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nameValue</span><span class="p">;</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">objectValue</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>이 템플릿 클래스 안에는 생성자가 선언되어 있으므로, 컴파일러는 기본 생성자를 만들어 내지 않는다. 반면에 복사 생성자나 복사 대입 연산자는 선언되어 있지 않기 때문에, 이 두 함수의 기본형이 컴파일러에 의해 만들어 진다(물론 필요에 의해서).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">NamedObject</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">no1</span><span class="p">(</span><span class="s">&quot;Smallest Prime Number&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">NamedObject</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">no2</span><span class="p">(</span><span class="n">no1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>컴파일러는 <code>no1.nameValue</code>와 <code>no1.objectValue</code>를 사용하여 <code>no2.nameValue</code> 및 <code>no2.objectValue</code>를 각각 초기화 한다.</p>

<p><code>nameValue</code>의 타입은 <code>std::string</code>이고, <code>std::string</code>은 자체적으로 복사 생성자를 갖고 있기 때문에 <code>no2.nameValue</code>의 초기화는 <code>std::string</code>의 복사 생성자에 <code>no1.nameValue</code>를 인자로 호출하여 이루어 진다.</p>

<p><code>objectValue</code>의 타입은 템플릿 인스턴스화에 의해 <code>int</code> 형이 되는데, <code>int</code>는 기본 제공 타입이므로 <code>no2.objectValue</code>는 <code>no1.objectValue</code>의 값을 그대로 복사해 오는 것으로 끝난다.</p>

<p>따라서 다음과 같은 기본형의 복사 생성자가 만들어 질 것이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">NamedObject</span><span class="p">(</span><span class="k">const</span> <span class="n">NamedObject</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
</span><span class='line'>    <span class="o">:</span> <span class="n">nameValue</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">nameValue</span><span class="p">),</span>
</span><span class='line'>      <span class="n">objectValue</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">objectValue</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>복사 대입 연산자가 자동 생성되지 않는 경우</h3>

<p>컴파일러가 만들어 주는 복사 대입 연산자도 근본적으로는 복사 생성자와 원리가 똑같다. 그러나 복사 대입 연산자의 자동 생성이 되려면 최종 코드가 &lsquo;적법해야(legal)&rsquo; 하고, &lsquo;이치에 맞아야만(reasonable)&rsquo; 한다. 둘 중 하나라도 만족하지 못하면 컴파일러는 <code>operator=</code> 함수를 만들어내지 않는다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">NamedObject</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// 이 생성자는 이제 상수 타입의 name을 취하지 않는다.</span>
</span><span class='line'>    <span class="c1">// nameValue가 비상수 string의 참조자가 되었기 때문이다.</span>
</span><span class='line'>    <span class="c1">// 또한, 참조할 string을 가져야 하기 때문에 char* 는 없애 버렸다.</span>
</span><span class='line'>    <span class="n">NamedObject</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>    <span class="p">...</span> <span class="c1">// operator= 는 선언되지 않았다고 가정</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nameValue</span><span class="p">;</span> <span class="c1">// 참조자</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">T</span> <span class="n">objectValue</span><span class="p">;</span> <span class="c1">// 상수</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>자 그럼 다음과 같은 코드에선 어떤 일이 일어날까?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newDog</span><span class="p">(</span><span class="s">&quot;Persephone&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">oldDog</span><span class="p">(</span><span class="s">&quot;Satch&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">NamedObject</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">newDog</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="n">NamedObject</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">oldDog</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// p의 데이터 멤버에는 어떤 일이 일어날까?</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++에서 참조자와 상수는 중간에 변경이 불가능하므로 컴파일이 되지 않는다. 따라서 참조자나 상수 데이터 멤버를 갖고 있는 클래스의 경우, 대입 연산을 지원하기 위해서는 직접 복사 대입 연산자를 정의해 주어야 한다.</p>

<p>추가로 기반 클래스가 복사 대입 연산자를 <code>private</code>으로 선언한 경우, 파생 클래스는 암시적 복사 대입 연산자를 가질 수 없다. 파생 클래스에 대해 컴파일러가 만들어 주는 복사 대입 연산자는 기반 클래스의 복사 대입 연산자를 호출해야 하는데, <code>private</code>으로 되어 있으면 호출할 권한이 없기 때문이다.</p>

<blockquote><ul>
<li>컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Effective C++] Item 4. 객체를 사용하기 전에 반드시 그 객체를 초기화하자]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-4/"/>
    <updated>2016-04-25T13:17:29+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-4</id>
    <content type="html"><![CDATA[<h3>비멤버 객체 초기화</h3>

<p>객체의 값을 초기화 하는데 있어 C++는 복잡한 규칙을 따른다.
아래와 같은 경우,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>어떤 상황에서는 <code>x</code>의 값은 0으로 확실히 초기화되지만, 또 다른 상황에서는 x의 값이 보장되지 않는다. 또한,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="n">Point</span> <span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>p</code>의 데이터 멤버 역시 어떤 상황에서는 초기화가 보장되지만, 또 어떤 상황에서는 초기화가 보장되지 않는다. 대부분의 경우, 객체의 내부가 무작위 비트로 된 이상한 값을 갖게 된다.</p>

<p>C++의 객체 초기화는 나름대로의 규칙을 갖고 있지만, 이 규칙이 복잡하기 때문에 <strong>항상 초기화</strong>하는 습관을 들이는 것이 좋다.</p>

<p>비멤버 객체에 대해서는 초기화를 손수 해주어야 한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;A C-style string&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// 입력 스트림에서 읽음으로써 &quot;초기화&quot; 수행</span>
</span></code></pre></td></tr></table></div></figure>


<h3>멤버 객체 초기화</h3>

<p>멤버 객체는 생성자의 초기화 리스트로 초기화한다. 이때, <strong>그 객체의 모든 멤버를 초기화</strong>하는 습관을 들이자. 단, <strong>대입과 초기화를 구분</strong>하는 것이 중요하다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">PhoneNumber</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ABEntry</span>   <span class="c1">// Address Book Entry</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">ABEntry</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">address</span><span class="p">,</span>
</span><span class='line'>            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">PhoneNumber</span><span class="o">&gt;&amp;</span> <span class="n">phones</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">theName</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">theAddress</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">PhoneNumber</span><span class="o">&gt;</span> <span class="n">thePhones</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">numTimesConsulted</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">ABEntry</span><span class="o">::</span><span class="n">ABEntry</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">address</span><span class="p">,</span>
</span><span class='line'>                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">PhoneNumber</span><span class="o">&gt;&amp;</span> <span class="n">phones</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">theName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>       <span class="c1">// 이것은 초기화가 아니라 대입이다.</span>
</span><span class='line'>    <span class="n">theAddress</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
</span><span class='line'>    <span class="n">thePhone</span> <span class="o">=</span> <span class="n">phones</span><span class="p">;</span>
</span><span class='line'>    <span class="n">numTimesConsulted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++ 규칙에 의하면 어떤 객체이든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 전에 초기화되어야 한다고 명기되어 있다.</p>

<p><code>theName</code>과 <code>theAddress</code>, <code>thePhone</code>은 생성자 본문이 실행되기 전에 기본 생성자가 호출됨으로써 초기화가 수행되었고, 생성자 본문에서는 그냥 대입만 되고 있다.</p>

<p>그렇다면, <code>numTimesConsulted</code>도 미리 초기화가 되었을까? 꼭 그렇지만은 않다. 기본 제공 타입의 경우, 생성자 본문이 실행되기 전 초기화되리란 보장이 없다.</p>

<p>더욱 효과적으로 초기화를 하려면 어떻게 할까? 바로 <strong>멤버 초기화 리스트</strong>를 사용하는 것이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">ABEntry</span><span class="o">::</span><span class="n">ABEntry</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">address</span><span class="p">,</span>
</span><span class='line'>                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">PhoneNumber</span><span class="o">&gt;&amp;</span> <span class="n">phones</span><span class="p">)</span>
</span><span class='line'><span class="o">:</span> <span class="n">theName</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>       <span class="c1">// 이제 이들은 모두 초기화되고 있다.</span>
</span><span class='line'>  <span class="n">theAddress</span><span class="p">(</span><span class="n">address</span><span class="p">),</span>
</span><span class='line'>  <span class="n">thePhone</span><span class="p">(</span><span class="n">phones</span><span class="p">)</span>
</span><span class='line'>  <span class="n">numTimesConsulted</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span> <span class="p">}</span>                    <span class="c1">// 생성자 본문엔 이제 아무 것도 필요 없다.</span>
</span></code></pre></td></tr></table></div></figure>


<p>멤버 초기화 리스트를 이용한 방법은 대입을 이용한 방법보다 더 효율적일 가능성이 크다. 이전 버전은 기본 생성자로 미리 초기화를 해 놓은 후, 바로 대입을 하고 있기 때문에 먼저 호출된 기본 생성자에서 해놓은 초기화는 그냥 <strong>헛짓</strong>이 되고 만다.</p>

<p>따라서 기본 생성자 + 복사 대입 연산자보다 복사 생성자를 한번만 호출하는 쪽이 대부분의 데이터 타입의 경우, 더 효율적이기 때문이다.</p>

<h3>멤버를 기본 생성자로 초기화</h3>

<p>데이터 멤버를 기본 생성자로 초기화하고 싶을 땐 다음과 같이 한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">ABEntry</span><span class="o">::</span><span class="n">ABEntry</span><span class="p">()</span>
</span><span class='line'><span class="o">:</span> <span class="n">theName</span><span class="p">(),</span> <span class="c1">// 기본 생성자 호출</span>
</span><span class='line'>  <span class="n">theAddress</span><span class="p">(),</span>
</span><span class='line'>  <span class="n">thePhone</span><span class="p">()</span>
</span><span class='line'>  <span class="n">numTimesConsulted</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>위와 같이 기본 생성자를 호출하는 것이 약간 오버처럼 느껴질 수도 있다. 어떤 데이터 멤버가 멤버 초기화 리스트에 들어가지 않았고 그 데이터 멤버가 사용자 정의 타입이면, 컴파일러가 자동으로 기본 생성자를 호출하게 되기 때문이다. 그러나 기본 제공 타입은 기본값 같은 것이 없기 때문에(<em>C 언어의 특성상</em>) 초기화가 되지 않는다.</p>

<p>기본 제공 타입은 초기화와 대입에 들어가는 비용에 거의 차이가 없기 때문에 생성자 본문에 넣어도 되지 않을까 라는 생각을 가질 수 있다. 그러나 기본 제공 타입이 상수 혹은 참조자로 되어 있는 경우는 대입 자체가 불가능하기 때문에 무조건 멤버 초기화 리스트에 넣어 주어야 한다.</p>

<p>이렇듯 규칙이 너무 복잡하기 때문에 골치가 아파진다. 그냥 이것저것 따지지 말고, 멤버 초기화 리스트에서 모든 멤버를 초기화해 주는 쪽이 속이 편하다.</p>

<p>현장에서 쓰이는 많은 클래스가 여러 개의 생성자를 갖고 있다. 그리고 각 생성자마다 멤버 초기화 리스트가 붙어 있을 것이다. 이런 클래스에 데이터 멤버와 부모 클래스가 적지 않게 붙어 있다면, 각 생성자마다 멤버 초기화 리스트가 주렁주렁 매달려 있을 것이다. 같은 멤버들의 초기값이 중복되어 출현할 것이고, 프로그래머가 보기에도 코드가 지겨워질 것은 불을 보듯 뻔한 일이다.</p>

<p>이럴 때는 대입으로도 초기화가 가능한 데이터 멤버들을 별도의 함수로 빼내어(대게 <code>private</code> 함수) 초기화를 시키는 방법을 사용하면 되지만, 이런 가짜 초기화보다는 아무래도 멤버 초기화 리스트를 사용하는 쪽이 더 좋을 것이다.
(C++11 에서는 이런 문제를 해결할 수 있는 방법이 존재합니다. 자세한 내용은 <a href="http://langgeek.tistory.com/entry/C11-%EC%83%9D%EC%84%B1%EC%9E%90-%EC%9C%84%EC%9E%84">[C++11] 생성자 위임</a> 글 참조)</p>

<h3>초기화 순서</h3>

<p>이처럼 변덕스러운 C++의 객체 초기화에도 변하지 않는 것이 딱 하나 있다. (1) <strong>기본 클래스는 파생 클래스보다 먼저 초기화</strong>되고(항목 12 참조), (2) 클래스 데이터 멤버는 그들이 <strong>선언된 순서대로 초기화</strong>된다는 사실이다.</p>

<p><code>ABEntry</code>로 예를 들면, 가장 먼저 <code>theName</code>이 초기화되고, 두번째로 <code>theAddress</code>, 세번째로 <code>thePhones</code>, 그리고 마지막으로 <code>numTimesConsulted</code>가 초기화된다.</p>

<p>어쩌다가 멤버 초기화 리스트에 이들이 넣어진 순서가 다르더라도, 초기화 순서는 선언된 순서를 따라간다. 멤버 초기화가 서로 얽혀 있다면 이 같은 문제는 찾기 어려운 버그를 만들어 내므로, <strong>멤버 초기화 리스트에 넣는 멤버들의 순서를 클래스에 선언한 순서와 동일하게</strong> 맞춰주자.</p>

<h3>비지역 정적 객체(non-local static object)의 초기화 순서</h3>

<p><strong>서로 다른 번역 단위에서 정의된 비지역 정적 객체들 사이의 상대적인 초기화 순서는 정해져 있지 않다.</strong></p>

<ul>
<li><strong>정적 객체</strong>: 자신이 생성된 시점부터 프로그램이 끝날 때까지 살아 있는 객체로 아래 다섯가지가 있다.</li>
<li>전역 객체</li>
<li>네임스페이스 유효범위에서 정의된 객체</li>
<li>클래스 안에서 <code>static</code>으로 선언된 객체</li>
<li>함수 안에서 <code>static</code>으로 선언된 객체</li>
<li>파일 유효범위에서 <code>static</code>으로 선언된 객체</li>
</ul>


<blockquote><p>스택 객체(지역 객체) 및 힙 객체(<code>new</code> 혹은 <code>malloc</code>으로 할당된 객체, 다른 말로 동적 객체)는 정적 객체가 아니다.</p></blockquote>

<p>위 다섯가지 중, 함수 안에 있는 정적 객체는 지역 정적 객체, 나머지는 비지역 정적 객체라고 한다.</p>

<p>이 다섯 종류의 정적 객체는 프로그램이 끝날 때(<code>main()</code> 함수의 실행이 끝날 때) 자동으로 소멸된다.</p>

<ul>
<li><strong>번역 단위(translation unit)</strong>: 컴파일을 통해 하나의 목적 파일(object file)을 만드는 바탕이 되는 소스 코드. 기본적으로는 소스 파일 하나와 그 파일이 <code>#include</code>하는 파일들까지 합쳐서 하나의 번역 단위가 된다.</li>
</ul>


<p>객체의 초기화 순서 문제는 다음과 같은 경우에 발생한다.</p>

<ol>
<li>별도로 컴파일된 소스 파일이 두 개 이상 있으며</li>
<li>각 소스 파일에 비지역 정적 객체가 한 개 이상 들어있고</li>
<li>한 쪽 번역 단위에 있는 객체의 초기화가 진행되면서, 다른 쪽에 있는 비지역 정적 객체가 사용될 때</li>
</ol>


<p>위의 경우에 비지역 정적 객체의 초기화 순서가 정해져 있지 않아 문제가 발생한다.</p>

<p>예를 보자. 아래와 같은 파일 시스템을 나타내는 클래스가 있고, 이 클래스로 만들어지는 객체는 단 하나만 존재해야 하기에 비지역 정적 객체로 만들었다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">FileSystem</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">numDisks</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">extern</span> <span class="n">FileSystem</span> <span class="n">tfs</span><span class="p">;</span> <span class="c1">// 사용자가 쓰게될 객체</span>
</span></code></pre></td></tr></table></div></figure>


<p>이제 사용자 측에서 <code>tfs</code>를 사용하여 디렉토리를 나타내는 클래스를 만들기로 하였다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Directory</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>        <span class="n">Directory</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
</span><span class='line'>        <span class="p">..</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">Directory</span><span class="o">::</span><span class="n">Directory</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">disks</span> <span class="o">=</span> <span class="n">tfs</span><span class="p">.</span><span class="n">numDisks</span><span class="p">();</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>그리고 이 클래스의 객체를 생성해서 사용하려고 하면</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Directory</span> <span class="n">tempDir</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>비지역 정적 객체의 초기화 순서가 정해져 있지 않기 때문에 문제가 발생할 수 있다.
<code>tempDir</code>을 생성하기 전에 <code>tfs</code>가 생성이 되어 있어야 하는데, 개별 번역 단위에 있기 때문에 <code>tfs</code>가 먼저 초기화되리란 보장이 없기 때문이다.</p>

<p>사실 비지역 정적 객체들의 초기화에 대해 적절한 순서를 결정하기란 매우 어려운 일이다.</p>

<p>다행히 이런 경우는 설계에 약간 변화만 주면 해결이 가능하다.</p>

<p>비지역 정적 객체를 하나씩 맡는 함수를 준비하고 이 안에 각 객체를 넣으면 된다. 함수 속에서도 이들을 정적 객체로 선언하고, 그 함수에서는 이들에 대한 참조자를 반환하게 만든다. 사용자 쪽에서는 비지역 정적 객체를 직접 참조하는 방식을 버리고 함수 호출로 대신한다. 즉 정리하자면, <strong>비지역 정적 객체를 지역 정적 객체로 바꾸는 것</strong>이다. (이는 싱글턴 패턴의 전형적인 방식이다.)</p>

<p>C++에서는(정확하게는 C) 지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때 초기화 되도록 만들어져 있다. 위의 방법은 이 사실을 이용한 것이다.</p>

<p>또한 비지역 정적 객체 대신에 준비한 지역 객체 참조자 반환 함수를 호출할 일이 없다면 해당 객체의 생성/소멸 비용도 생기지 않게 막아야 한다.</p>

<p>그리하여 이전 코드에 다음과 같은 변화를 주면</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">FileSystem</span> <span class="p">{...}</span> <span class="c1">// 이전과 같은 클래스</span>
</span><span class='line'>
</span><span class='line'><span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">tfs</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">FileSystem</span> <span class="n">fs</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">fs</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Directory</span> <span class="p">{...}</span> <span class="c1">// 이전과 같은 클래스</span>
</span><span class='line'>
</span><span class='line'><span class="n">Directory</span><span class="o">::</span><span class="n">Directory</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">disks</span> <span class="o">=</span> <span class="n">tfs</span><span class="p">().</span><span class="n">numDisks</span><span class="p">();</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Directory</span><span class="o">&amp;</span> <span class="n">tempDir</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">Directory</span> <span class="n">td</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">td</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>tempDir</code> 함수를 호출하기 전에는 <code>Directory</code> 객체도 생기지 않을 것이며 <code>FileSystem</code> 객체도 생기지 않을 것이다.</p>

<p>단, 다중 스레드 시스템에서는 위의 방법이 문제가 될 수도 있다. 비상수 정적 객체(지역 객체이든 비지역 객체이든)는 다중 스레드 시스템에서는 온갖 문제점을 야기할 수 있다. 한가지 방법은 프로그램이 다중 스레드로 돌입하기 전, 참조자 반환 함수를 전부 손으로 호출해 주어서 초기화에 관계된 경쟁 상태(race condition)를 피할 수 있다. 물론 객체들의 초기화 순서를 제대로 맞춰두기만 한다면 말이다.</p>

<blockquote><ul>
<li>기본 제공 타입의 객체는 직접 손으로 초기화한다. 경우에 따라 저절로 되기도 하고 안되기도 하기 때문이다.</li>
<li>생성자에서는 데이터 멤버에 대한 대입문을 본문 내부에 넣는 방법으로 멤버를 초기화하지 말고 멤버 초기화 리스트를 즐겨 사용하자. 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열하자.</li>
<li>여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 한다. 비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Effective C++] Item 3. 낌새만 보이면 const를 들이대 보자!]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-3/"/>
    <updated>2016-04-25T13:17:27+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-3</id>
    <content type="html"><![CDATA[<h3>포인터와 <code>const</code></h3>

<p><code>const</code> 키워드는 들어갈 수 있겠다 싶은 곳이면 어디든 붙일 수 있다.</p>

<p>포인터 타입에 대해서는 포인터 자체를 상수로, 혹은 포인터가 가리키는 대상을 상수로, 혹은 둘 다 지정할 수 있고, 아무것도 지정하지 않을 수도 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">char</span> <span class="n">greeting</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">;</span> <span class="c1">// 비상수 포인터, 비상수 데이터</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">;</span> <span class="c1">// 비상수 포인터, 상수 데이터</span>
</span><span class='line'><span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">;</span> <span class="c1">// 상수 포인터, 비상수 데이터</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">;</span> <span class="c1">// 상수 포인터, 상수 데이터</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>const</code> 키워드가 <code>*</code>의 왼쪽에 있으면 포인터가 가리키는 대상이 상수,
<code>const</code>가 <code>*</code>의 오른쪽에 있으면 포인터 자체가 상수이다.</p>

<p><code>const</code>가 <code>*</code>의 양쪽에 다 있으면 포인터가 가리키는 대상 및 포인터가 전부 상수이다.</p>

<p> 포인터가 가리키는 대상을 상수로 만들 때 const 를 사용하는 스타일이 다를 수 있는데,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span> <span class="o">*</span><span class="n">pw</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">Widget</span> <span class="k">const</span> <span class="o">*</span><span class="n">pw</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>위의 두 함수의 매개 변수 타입은 동일하다.</p>

<h3>STL과 <code>const</code></h3>

<p>STL 반복자(iterator)는 기본적인 동작 원리가 T* 포인터와 흡사합니다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">// iter는 T* const 처럼 동작합니다.</span>
</span><span class='line'><span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// OK, iter가 가리키는 대상을 변경한다.</span>
</span><span class='line'><span class="o">++</span><span class="n">iter</span><span class="p">;</span> <span class="c1">// 에러! iter는 상수</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">cIter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">// cIter는 const T* 처럼 동작합니다.</span>
</span><span class='line'><span class="o">*</span><span class="n">cIter</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 에러! cIter가 가리키는 대상이 상수</span>
</span><span class='line'><span class="o">++</span><span class="n">cIter</span><span class="p">;</span> <span class="c1">// OK, cIter를 변경한다.</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>const</code>의 가장 강력한 용도는 함수 선언에 쓸 경우이다.</p>

<p><code>const</code>는 함수 반환 값, 각각의 매개 변수, 멤버 함수 앞에 붙을 수 있고, 함수 전체에 대해 <code>const</code>의 성질을 붙일 수 있다.</p>

<h3>함수 반환 값을 상수로 만들기</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">Rational</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span><span class='line'><span class="k">const</span> <span class="n">Rational</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>함수의 반환 값이 상수일 때, 다음과 같은 어처구니 없는 실수를 막아준다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Rational</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// 에러!</span>
</span></code></pre></td></tr></table></div></figure>


<p>위와 같은 경우는 바로 알아챌 수 있겠지만, 다음과 같은 경우는 비교적 많이 일어난다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span> <span class="p">...</span> <span class="c1">// 타이핑 실수, 원래 비교하려고 했던건데...</span>
</span></code></pre></td></tr></table></div></figure>


<p>위의 코드는 <code>a</code>와 <code>b</code>가 기본 제공 타입이었다면 문법 위반에 걸리는 코드이지만, 사용자 정의 타입이기 때문에 허용된다.</p>

<h3>상수 멤버 함수</h3>

<p>멤버 함수에 붙는 <code>const</code> 키워드는 &ldquo;해당 멤버 함수가 상수 객체에 대해 호출될 함수이다&rdquo; 라는 사실을 알려준다.
이런 함수가 중요한 이유는 두 가지이다.</p>

<ol>
<li><p><strong>클래스의 인터페이스를 이해하기가 쉬워짐</strong>: 해당 클래스 객체의 상태를 변화시킬 수 없는 함수는 무엇이며, 변화시킬 수 있는 함수는 무엇인지 클래스 선언만 보고 바로 알 수 있다.</p></li>
<li><p><strong>해당 클래스의 상수 객체를 사용할 수 있게 해줌</strong>: C++ 프로그램의 실행 성능을 높이는 핵심 기법중의 하나인 &ldquo;상수 객체에 대한 참조자"를 쓰려면, 상수 멤버 함수가 준비되어 있어야 한다.</p></li>
</ol>


<p><code>const</code> 키워드가 있고 없고의 차이만 있는 멤버 함수들은 오버로딩이 가능하다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">TextBlock</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 상수 객체에 대한 operator[]                   _____</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span> <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 비상수 객체에 대한 operator[]</span>
</span><span class='line'>    <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span> <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>위 처럼 선언된 <code>TextBlock</code>의 <code>operator[]</code>는 다음과 같이 쓸 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">TextBlock</span> <span class="nf">tb</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 비상수 멤버 호출</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">TextBlock</span> <span class="nf">ctb</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 상수 멤버 호출</span>
</span></code></pre></td></tr></table></div></figure>


<p>위 예제는 이해를 돕기위한 용도가 크고, 실제 프로그램에서 상수 객체가 자주 생기는 경우는 <strong>상수 객체에 대한 포인터 혹은 참조자가 함수의 인자로 전달될 때</strong>이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">TextBlock</span><span class="o">&amp;</span> <span class="n">ctb</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">ctb</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>또한 상수 객체와 비상수 객체의 쓰임새가 아래처럼 달라질 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// OK</span>
</span><span class='line'><span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span> <span class="c1">// OK</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// OK</span>
</span><span class='line'><span class="n">ctb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span> <span class="c1">// 에러!</span>
</span></code></pre></td></tr></table></div></figure>


<p>상수 객체의 반환 타입이 <code>const char&amp;</code>이기 때문에 넷째줄에서 에러가 발생했다.</p>

<p>비상수 버전의 <code>operator[]</code>는 참조자를 반환해야 한다. 만약 그냥 <code>char</code>를 반환한다면, 다음 문장은 컴파일되지 않는다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>기본 제공 타입을 반환하는 함수의 반환 값을 수정하는 일은 불가능하다. 만약 된다고 해도, <strong>&lsquo;값에 의한 반환&rsquo;</strong>을 수행하는 C++의 특성상 수정되는 값은 <code>tb.text[0]</code>의 사본이지 <code>tb.text[0]</code>의 값이 아니다.</p>

<h3>비트수준 상수성과 논리적 상수성</h3>

<ul>
<li>비트수준 상수성(물리적 상수성): 멤버 함수가 <code>const</code>이려면 그 객체의 어떤 데이터 멤버(정적 멤버는 제외)도 바꾸지 않아야 함.</li>
</ul>


<p>C++에서 정의하고 있는 상수성도 비트수준 상수성이고, 컴파일러 차원에서 비트수준 상수성을 지키는 것은 매우 쉽지만, 포인터가 가리키는 대상을 변경하는 경우, 컴파일러가 잡아내지 못한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CTextBlock</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 부적절한(그러나 비트수준 상수성을 지키는 것처럼 보여져서 허용되는) 선언</span>
</span><span class='line'>    <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span> <span class="k">return</span> <span class="n">pText</span><span class="p">[</span><span class="n">position</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">pText</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>operator[]</code> 내부 코드만 보면 <code>pText</code>를 바꿀 수 없다는 것은 확실하다. 그러나 다음과 같은 코드에서는</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="n">CTextBlock</span> <span class="nf">cctb</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cctb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="sc">&#39;J&#39;</span><span class="p">;</span> <span class="c1">// OK, cctb는 이제 &quot;Jello&quot;라는 값을 가짐</span>
</span></code></pre></td></tr></table></div></figure>


<p>상수 객체에 대고 상수 멤버 함수 밖에 호출한 적이 없는데 내부의 값이 변해 버렸다.</p>

<p>논리적 상수성은 이런 황당한 상황을 보완하는 개념으로 나오게 되었다.</p>

<ul>
<li><strong>논리적 상수성</strong>: 상수 멤버 함수라고 해서 객체를 조금도 바꿀 수 없는 것이 아니라, 일부는 바꿀 수 있되, 사용자측이 알아채지 못하게만 하면 상수 멤버 자격이 있다.</li>
</ul>


<p>예를 들어, 클래스 내부의 캐시 데이터를 업데이트하는 용도가 이런 경우에 해당된다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CTextBlock</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">pText</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">textLength</span><span class="p">;</span> <span class="c1">// 바로 직전에 계산한(캐시된) 텍스트 길이</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">lengthIsValid</span><span class="p">;</span> <span class="c1">// 이 길이(캐시)가 현재 유효한가?</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">CTextBlock</span><span class="o">::</span><span class="n">length</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lengthIsValid</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">textLength</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">pText</span><span class="p">);</span> <span class="c1">// 에러!</span>
</span><span class='line'>        <span class="n">lengthIsValid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 에러!</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">textLength</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>위 코드는 효율적인 측면을 고려하여 <code>textLength</code>의 값을 캐시해 놓는다.
그리고 사용자는 <code>length()</code>가 어떤식으로 구현되어 있던 간에 <code>pText</code>의 값이 변하지 않을 것을 알고 함수를 호출할 것이다.
이때 이 함수는 논리적 상수성을 지키고 있는 것이다.
그러나 컴파일러가 비트수준 상수성을 강제하고 있기 때문에 컴파일 에러가 발생한다.
이를 해결할 방법은 mutable 키워드를 이용하는 것이다.
이 키워드가 붙은 데이터 멤버는 상수 멤버 함수 안에서도 수정이 가능해진다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">CTextBlock</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">pText</span><span class="p">;</span>
</span><span class='line'>    <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">textLength</span><span class="p">;</span> <span class="c1">// 바로 직전에 계산한(캐시된) 텍스트 길이</span>
</span><span class='line'>    <span class="k">mutable</span> <span class="kt">bool</span> <span class="n">lengthIsValid</span><span class="p">;</span> <span class="c1">// 이 길이(캐시)가 현재 유효한가?</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">CTextBlock</span><span class="o">::</span><span class="n">length</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lengthIsValid</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">textLength</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">strlen</span><span class="p">(</span><span class="n">pText</span><span class="p">);</span> <span class="c1">// OK</span>
</span><span class='line'>        <span class="n">lengthIsValid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// OK</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">textLength</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>상수 멤버 및 비상수 멤버 함수에서 코드 중복 현상을 피하는 방법</h4>

<p><code>TextBlock::operator[]</code>가 기능이 확장되어(경계 검사, 접근 데이터 로깅, 무결성 검증 등) 코드가 비대해지면, 아무리 개별 함수로 빼낸다 해도 코드 중복이 생길 수 밖에 없다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">TextBlock</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 경계 검사</span>
</span><span class='line'>        <span class="c1">// 접근 데이터 로깅</span>
</span><span class='line'>        <span class="c1">// 무결성 검증</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 경계 검사</span>
</span><span class='line'>        <span class="c1">// 접근 데이터 로깅</span>
</span><span class='line'>        <span class="c1">// 무결성 검증</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>코드 중복은 절대악이다. 컴파일 시간, 유지보수 시간, 바이너리 크기 부풀림 등&hellip;
캐스팅을 써서 위와 같은 코드 중복을 피할 수 있다.
캐스팅은 기본적으로 피해야할 기법이지만, 코드 중복이 더 해악이므로 캐스팅을 사용한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">TextBlock</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 경계 검사</span>
</span><span class='line'>        <span class="c1">// 접근 데이터 로깅</span>
</span><span class='line'>        <span class="c1">// 무결성 검증</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">position</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>            <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&amp;&gt;</span><span class="p">(</span>
</span><span class='line'>                <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TextBlock</span><span class="o">&amp;&gt;</span>
</span><span class='line'>                    <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">position</span><span class="p">]</span>
</span><span class='line'>            <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>첫번째 캐스팅인 <code>static_cast</code>는 무한 재귀 호출을 피하기 위해, 즉 상수 버전의 <code>operator[]</code>를 호출하기 위해 사용되었고, 두번째 캐스팅인 <code>const_cast</code>는 결과에서 <code>const</code>를 떼어내기 위해 사용되었다.</p>

<p>물론 C 스타일의 캐스팅을 사용하면 괄호 만으로도 끝나겠지만, <strong>C 스타일의 캐스팅 보다는 C++ 스타일의 캐스팅을 사용해야 한다</strong>(항목 27 참조).</p>

<p>비상수 멤버 함수에서 상수 멤버 함수를 호출하는 이유는 반대로 생각하면 간단해 진다.</p>

<p>만약 <strong>상수 멤버 함수 쪽에서 비상수 멤버 함수 쪽을 호출했다면, 상수 멤버 함수로써는 비트 수준 상수성이 간단하게 깨지게 되는 것</strong>이기 때문이다.</p>

<blockquote><ul>
<li><code>const</code>를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 준다.</li>
<li>컴파일러는 비트수준 상수성을 지켜야 하지만, 우리는 논리적인 상수성을 사용하여 프로그래밍해야 한다.</li>
<li>상수 멤버 함수 및 비상수 멤버 함수가 서로 동일한 기능으로 구현되어 있을 경우, 비상수 버전이 상수 버전을 호출하도록 만들자.</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Effective C++] Item 2. #define을 쓰려거든 const, enum, inline을 떠올리자]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-2/"/>
    <updated>2016-04-25T13:14:02+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-2</id>
    <content type="html"><![CDATA[<h3>컴파일 타임 상수 대체하기</h3>

<p>아래와 같은 define 문이 있을 때,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#define ASPECT_RATIO 1.653</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ASPECT_RATIO</code>라는 이름은 심볼은 컴파일러에겐 전혀 보이지 않는다(컴파일러의 심볼 테이블에 들어가지 않음). 선행 처리자가 숫자 상수로 바꾸어 버리기 때문이다.</p>

<p>이 때문에 생길 수 있는 문제는 다음과 같다.</p>

<ul>
<li>컴파일 에러가 발생하면 <code>ASPECT_RATIO</code>라는 심볼보다는 <code>1.653</code>이라는 상수를 마주하게 될 것이므로, 버그를 찾기가 어려워 진다. (더군다나 <code>ASPECT_RATIO</code>가 정의된 파일이 프로젝트 내에 있지 않을 경우, 찾기가 더욱 곤란해 질 수 있음)</li>
<li>심볼릭 디버거에서도 <code>ASPECT_RATIO</code>라는 심볼 대신에 숫자를 보여주므로 디버깅이 어려워 질 수 있다.</li>
</ul>


<p>이 문제를 해결할 수 있는 방법은 매크로 대신 상수를 쓰는 것이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">double</span> <span class="n">AspectRatio</span> <span class="o">=</span> <span class="mf">1.653</span><span class="p">;</span> <span class="c1">// 대문자로만 표기하는 이름은 보통 매크로에서 쓰는 것이라서, 이름 표기도 바꿔줌</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>AspectRatio</code>는 컴파일러의 심볼 테이블에 들어가게 된다.
또한 추가로 얻을 수 있는 이점은 컴파일된 코드의 크기가 작아질 수 있다는 것인데, <code>#define</code>을 쓸 경우 사용된 개수만큼 해당 숫자의 사본이 생기게 되는데, 상수의 경우는 사본이 딱 한개만 생기기 때문이다(몇몇 CPU 아키텍쳐에서는 작은 정수 값에 대해서 Instruction Code 내부에 Immediate 타입의 값을 직접 저장할 수 있으므로, 해당이 되지 않을 수 있음).</p>

<p><code>#define</code> 을 상수로 교체하려는 경우, 두가지 경우만 조심하자.</p>

<ol>
<li><strong>상수 포인터를 정의하는 경우</strong>: 보통 헤더 파일에 넣는 것이 관례이므로, 포인터는 꼭 <code>const</code>로 선언해 주어야 하고, 포인터가 가리키는 대상까지 const로 선언해 주어야 한다.</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">authorName</span> <span class="o">=</span> <span class="s">&quot;Scott Meyers&quot;</span><span class="p">;</span> <span class="c1">// const의 의미와 사용법에 대한 자세한 사항은 항목 3 참조</span>
</span></code></pre></td></tr></table></div></figure>


<p>문자열 상수에는 <code>char*</code>같은 구닥다리 문자열 보다는 <code>string</code> 객체가 더 사용하기 편하다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">authorName</span><span class="p">(</span><span class="s">&quot;Scott Meyers&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li><strong>클래스 상수를 정의하는 경우</strong>: 어떤 상수의 유효범위를 클래스로 한정하고자 할 때, 그 상수의 사본 개수가 한개를 넘지 못하게 하고 싶다면 정적(static) 멤버로 만들어야 한다.</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">GamePlayer</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">NumTurns</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 상수 선언(declaration)</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="n">NumTurns</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++ 에서는 대부분의 것들에서 정의가 마련되어 있어야 하지만, 정적 멤버로 만들어지는 정수류(각종 정수 타입, <code>char</code>, <code>bool</code> 등) 타입의 클래스 내부 상수는 예외이다.
이들에 대해 주소를 취하지 않는 한, 정의 없이 선언만 해도 아무 문제가 없다.</p>

<p>단, 클래스 상수의 주소를 구해야 한다면 얘기가 달라진다.</p>

<p><code>const int GamePlayer::NumTurns;</code></p>

<p>이 클래스 상수의 정의는 구현 파일에 두어야 한다. 또한 클래스 상수의 초기값은 해당 상수가 선언된 시점(헤더 파일)에 바로 주어지기 때문에 정의(구현 파일)에는 초기 값을 주지 않는다.</p>

<p>상수의 주소를 구한다거나, 상수의 참조자를 취하는 일을 막으려면 <code>enum</code>을 쓰면 된다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">GamePlayer</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="k">enum</span> <span class="p">{</span> <span class="n">NumTurns</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">};</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="n">NumTurns</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>const</code>의 주소를 구하는 것은 합당하지만, <code>enum</code>의 주소를 구하는 것은 안되기 때문이다.
<code>enum</code>은 어떠한 형태의 쓸데없는 메모리 할당도 절대 저지르지 않는다.</p>

<h3>매크로 함수 대체하기</h3>

<p><code>#define</code>을 잘못 사용하는 경우는 종종 매크로 함수에서 볼 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// 매크로 함수의 인자는 항상 괄호로 싸서, 표현식이 변형되는 것을 막아주자.</span>
</span><span class='line'><span class="cp">#define CALL_WITH_MAX(a, b) func((a) &gt; (b) ? (a) : (b))</span>
</span><span class='line'><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">CALL_WITH_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// a가 두 번 증가</span>
</span><span class='line'><span class="n">CALL_WITH_MAX</span><span class="p">(</span><span class="o">++</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// a가 한 번 증가</span>
</span></code></pre></td></tr></table></div></figure>


<p>이처럼 표현식의 결과에 따라 인자가 평가되는 횟수가 달라진다.</p>

<p>C++ 에서는 기존 매크로의 효율을 그대로 유지하면서 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽하게 취할 수 있는 방법이 있다.
바로 인라인 템플릿 함수(항목 30 참조)를 만드는 것이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="kr">inline</span> <span class="kt">void</span> <span class="n">callWithMax</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="c1">// T가 정확히 어떤 타입인지 모르기 때문에, 상수 객체에 대한 참조자를 씀. (항목 20 참조)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">f</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>함수 본문에 지저분하게 괄호를 넣을 필요도 없고, 인자를 여러 번 평가하지도 않는다.
뿐만 아니라 진짜 함수이기 때문에, 유호범위 및 접근 규칙을 그대로 따라간다.
임의의 클래스 안에서만 쓸 수 있는 인라인 함수가 가능하다는 얘기다.</p>

<blockquote><ul>
<li>단순한 상수를 쓸 때는, #define 보다 const 객체 혹은 enum 을 우선 생각하자.</li>
<li>함수처럼 쓰이는 매크로를 만들려면, #define 매크로보다 인라인 함수를 우선 생각하자.</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Effective C++] Item 1. C++를 언어들의 연합체로 바라보는 안목은 필수]]></title>
    <link href="http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-1/"/>
    <updated>2016-04-25T12:57:50+09:00</updated>
    <id>http://chozekun.github.io/blog/2016/04/25/effective-c-plus-plus-item-1</id>
    <content type="html"><![CDATA[<p>C++ 은 다중 패러다임 언어다.</p>

<ul>
<li>절차적 프로그래밍</li>
<li>객체 지향 프로그래밍</li>
<li>함수형 프로그래밍</li>
<li>일반적 프로그래밍</li>
<li>메타프로그래밍</li>
</ul>


<p>C++ 는 4개의 하위 언어로 구성되어 있다.</p>

<ul>
<li><p><strong>C 언어</strong>: C++ 의 근간은 C 언어다. 블록, 문장, 선행 처리자, 원시 데이터 타입, 배열, 포인터 등. 이들 중 상당수는 구식의 것이며 C++ 의 것으로 대체할 수 있는 방법을 활용하는 것이 좋다. 그러나 C++ 개발자라면 이들 개념에 대해 정확히 알고 있어야 할 것이다.</p></li>
<li><p><strong>객체 지향 C++</strong>: 클래스(생성자와 소멸자), 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩) 등.</p></li>
<li><p><strong>템플릿 C++</strong>: 일반화 프로그래밍 영역. 템플릿의 힘은 너무나도 강력해서 새로운 프로그래밍 패러다임이 생기기도 하였다(템플릿 메타프로그래밍).</p></li>
<li><p><strong>STL</strong>: 표준 템플릿 라이브러리(Standard Template Library). 컨테이너, 반복자, 알고리즘, 함수 객체가 얽혀있다. STL은 나름대로 정형화된 사용 규칙이 있기 때문에 그 규칙을 따라 사용한다.</p></li>
</ul>


<p>C++에서는 이들 개념을 자유자재로 사용하는 것이 중요하다.</p>

<p><strong>원시 데이터 타입</strong>에 대해서는 참조 전달 보다는 <strong>값 전달</strong>을 하는 것이 더 좋다.</p>

<p><strong>사용자 정의 타입</strong>에 대해서는(생성자와 소멸자의 개념 때문에) <strong>상수 객체 참조자에 의한 전달(pass-by-reference-to-<code>const</code>)</strong>이 더 좋다.</p>

<p>그러나 <strong>STL의 반복자와 함수 객체</strong>에 대해서는(C 언어의 포인터를 본떠 만든 것이기 때문에) <strong>값 전달</strong>을 쓰는 것이 더 좋다(매개 변수 전달 방법을 결정하는 사항은 항목 20에서 살펴봄).</p>

<blockquote><p>C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라진다. 그 경우란, 바로 C++의 어떤 부분을 사용하느냐다.</p></blockquote>
]]></content>
  </entry>
  
</feed>
